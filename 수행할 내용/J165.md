## ✅ 수행할 퀘스트
### 4. 코드 리뷰 시간 부족: AI의 코드 리뷰와 내 리뷰 비교해보기

---

## 💡 선택한 이유

솔직히 동료 코드를 리뷰할 때면 어디서부터 어떻게 접근해야 할지 막막할 때가 많았습니다. 단순히 '좋은 코드'를 찾는 것을 넘어, 그 안에 담긴 깊은 고민과 아이디어를 배우고 싶었지만 제 경험만으로는 한계가 느껴지곤 했습니다. 특히 여러 명의 코드를 한정된 시간 안에 리뷰해야 할 때는 시간 압박 때문에 흐름을 놓치거나 피상적인 피드백에 그치는 경우도 많았습니다.

이 퀘스트는 AI의 도움으로 코드의 흐름과 핵심 로직을 더 빠르게 이해하고, 제가 놓치기 쉬운 부분까지 보완할 수 있을 것 같아 선택했습니다. AI의 리뷰와 제 리뷰를 비교하면서 분석 관점을 넓히면 동료들에게 더 깊이 있는 피드백을 줄 수 있고, 동시에 제 코드리뷰 역량도 한 단계 성장할 것이라 기대합니다.

---

## 🧭 수행 계획

### 1. 동료 코드 전처리
AI가 코드의 핵심 흐름을 이해하기 쉽도록 전처리 작업 수행.

    불필요한 코드 제거: CSS, 마크업 등 로직과 무관한 부분 제외

    중요 로직 추출: 메인 함수, API 호출부 등 주요 로직만 추려내기

    맥락 제공: AI가 잘못된 추론을 하지 않도록 코드 설명이나 실행 흐름 맥락 간단히 메모

> 전처리 후 파일 사이즈를 AI가 처리 가능한 범위로 줄인다.


### 2. AI 프롬프트 설계
AI가 원하는 형식으로 답변하도록 프롬프트 작성

요청 포인트:

    로직 요약

    변수/함수 역할 설명

    성능·가독성 개선 가능성 분석


프롬포트 예시:

    "아래 코드는 A라는 기능을 구현합니다. 주요 로직의 흐름을 단계별로 설명해줘"

    "코드 이해를 돕도록 주석을 추가해줘"

    "이 코드에 사용된 주요 CS 개념과 패턴을 3가지로 요약해줘"

### 3. AI 리뷰 결과와 비교
AI가 작성한 리뷰 결과와 내가 작성한 리뷰를 나란히 놓고 비교

비교 포인트:

    내가 놓친 핵심 로직이 있는지?

    불필요하게 깊이 들어간 부분이 있는지?

    AI가 제안한 개선점 중 수용할 만한 것이 있는지?

### 4. 개선 및 피드백 적용
도출한 개선 포인트를 다음 코드 리뷰에 바로 적용

동료 코드의 흐름을 더 빠르고 깊게 이해할 수 있는 나만의 리뷰 루틴 정립

---

## 📌 수행 기록
### 1일차 [20250721]
- 진행

    - 월요일은 피어 컴파일링 시간이 없기 때문에, AI에게 앞으로의 역할과 코드 분석 방법, 기대 출력값을 프롬포트로 리마인드시켜주었다.

        > 문제 스포가 될 수 있기때문에 수행 기록에는 `코드 개선점 + 피드백` 부분만 인용

- 결과
    - 분석 기준 설계

        ```gpt
        ✅ 분석 기준
        1. 로직 흐름 요약
        코드의 주요 흐름을 단계별로 도식화하듯 정리

        2. 변수 및 함수 역할
        주요 변수 및 함수의 책임, 관여 범위, 내부 처리 정리

        3. 성능 및 가독성 개선 여부
        불필요한 연산, 중복, 메모리 낭비, 비동기 흐름 관리 등 성능 측면

        네이밍, 분기 구조, 상태 관리 등 가독성과 유지보수성 측면
        ```

    - 진행 순서 설계

        ```gpt
        그러면 다음 순서로 진행하겠습니다:

        1. 먼저 미션 내용을 공유해 주세요.

        2. 그 다음 전처리된 코드를 주시면,

        3. 미션 맥락에 맞춰서 로직 분석 + 변수 역할 + 개선점까지 세밀하게 짚어드릴게요.

        준비되시면 미션부터 주세요.
        ```

    - 회고

        분석 기준과 절차를 사전에 정리해두니 앞으로 반복되는 작업에서도 일관성을 유지할 수 있을 것 같아 기대된다.
    
        예상대로 AI가 흐름을 잘 따라올지, 정밀한 분석이 실제로 문제 해결에 얼마나 도움이 될지 궁금하지만, 초기 설계 방향 자체는 꽤 괜찮은 느낌이다.

### 2일차 [20250722]
- 진행

    - 미션 내용을 AI에게 먼저 학습시킨 뒤, J088님의 미션 코드를 전처리하여 프롬프트로 전달했다. 
    
        > 여러 파일로 나뉜 코드를 AI가 문맥에 맞게 이해할 수 있도록 구성하는 데 집중했다.

- 결과

    <details>
    <summary>코드 개선 피드백 결과</summary>

    ### 성능·가독성 개선 분석
    🔹 [1] Controller 구조 개선
    문제:

    ```js
    this.rl.question('명령을 입력하세요>');
    const { from, to } = parseCommand( ... from, to)
    ```
    from, to를 질문 전에 선언하지 않아 오류 발생

    printUserBoard를 함수 호출이 아닌 참조만 함

    개선안:

    ```js
    this.rl.question('명령을 입력하세요> ', (input) => {
    try {
        const { from, to } = parseCommand(input);
        // 이후 이동/공격 로직 수행
        this.turn = 'COMPUTER';
    } catch (err) {
        console.log('입력 오류:', err.message);
    }
    this.nextTurn();
    });
    ```
    🔹 [2] 클래스 분리와 추상화 구조 우수
    Character 추상화 + canMove() 오버라이딩 구조는 OOP 원칙 잘 반영됨

    예외 처리를 활용해 “강제 override”를 유도한 점도 적절:

    ```js
    throw new Error('이동규칙 정의 필요');
    ```
    🔹 [3] 중복 제거 및 일반화 가능성

    ```js
    getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
    }
    ```
    유틸 함수로 utils.js로 이동 가능

    반복되는 캐릭터 배치 로직도 별도 placeWithValidation() 함수로 추출 가능
    </details>
    </br>

    - 종합 피드백 (총평)

        | 항목         | 평가          | 설명                                                             |
        | ---------- | ----------- | -------------------------------------------------------------- |
        | **OOP 설계** | ✅ 훌륭함       | 상속, 추상 메서드, 역할 분리 매우 잘 설계됨                                     |
        | **유지보수성**  | ⚠️ 좋음       | 위치와 숫자 제약이 `initBoard.js` 내부에 하드코딩됨 → 설정 분리 추천                 |
        | **가독성**    | ⚠️ 개선 여지 있음 | `Controller` 내부 async 흐름 미완성 / 일부 함수 누락                        |
        | **버그 가능성** | 🔥 있음       | `Thanos.attackPower`, `Controller.printUserBoard()` 함수 호출 누락 등 |

- 회고

    요구사항이 많고 파일 수도 많아서 제대로 분석되지 않을까 걱정했는데, 예상보다 훨씬 세세한 버그까지 짚어줘서 컴파일링 과정이 수월하게 진행됐다.
    
    앞으로는 오늘처럼 파일이 많은 경우, 파일을 자동 전처리해주는 AI 워크플로우도 함께 고려해봐야겠다는 생각이 들었다.
### 3일차
- 진행

    미션 내용을 먼저 AI에게 학습시킨 뒤, J141님의 미션 코드를 전처리하여 프롬프트로 전달했다. 
    
        > 코드 전체의 구조와 흐름을 파악할 수 있도록 핵심 파일 중심으로 정리해 제공했다.

- 결과

    - 종합 피드백

    ```markdown
    ✅ 1. 전체적인 구조와 역할 분담이 훌륭합니다.
        FileSystem 클래스는 디스크, FAT, 디렉토리 등 핵심 구성 요소들을 잘 분리해 협력시키고 있습니다.

        각 기능은 함수 단위로 명확하게 분리되어 있어, 가독성과 유지보수성이 우수합니다.

        예외처리(try-catch)와 에러 메시지도 적절하게 포함되어 있어 실사용을 고려한 구조입니다.

    💡 전체적으로 봤을 때, "현실의 파일 시스템을 작게 축소해서 흉내낸 구조로서 매우 이상적인 설계입니다."

    🧠 2. 객체지향적인 감각이 좋습니다.
        Directory, TextFile, FATTable 등 도메인 모델이 명확하게 분리되어 있습니다.

        특히 serialize(), deserialize() 패턴을 활용하여 메모리 ↔ 파일 간 전환을 자연스럽게 처리한 점이 인상적입니다.

        디스크 블록을 FATTable을 통해 연결하는 방식은 실제 파일 시스템과 유사한 구조로 설계되었습니다.

    💾 3. 영속성 처리에서 높은 완성도를 보여줍니다.
        파일 시스템 상태를 .dat, .info, .dir 파일에 나누어 저장함으로써 복원까지 고려한 완성도 있는 구조입니다.

        이는 단순한 메모리 시뮬레이터가 아닌, *"파일 시스템 운영체제의 일부를 구현한 수준"*에 가깝습니다.
    ```

    - 추천 디버깅/보안 항목

        | 항목         | 내용                                                     |
        | ---------- | ------------------------------------------------------ |
        | 에러 메시지 포맷  | `createFile`, `createDir` 등에서 콘솔 로그 외에 예외 throw도 옵션 제공 |
        | 대용량 파일 테스트 | 블록 체인 방식 잘 작동하는지 파일 크기 > blockSize × 2 로 확인            |
        | 경로 보정 로직   | `/hello//world///` 와 같이 중복 슬래시 처리 여부 확인 필요             |
        | 파일 확장자 검사  | `.txt` 강제 검증 로직 추가 필요 (`createFile()`에서)               |

- 회고

    단순히 구조 요약에 그치지 않고, 디버깅 포인트나 보완해야 할 항목까지 정리해줘서 피어 피드백 시 참고자료로 매우 유용할 것 같다.

    매 미션마다 요구사항과 구조가 다르기 때문에, 그에 맞춰 분석 기준을 유동적으로 조정하는 접근도 효과적일 것 같다는 생각이 들었다.
### 4일차

### 5일차